{"ast":null,"code":"import _regeneratorRuntime from \"@babel/runtime/regenerator\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"next\", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, \"throw\", err); } _next(undefined); }); }; }\n\n;\n\n(function ($) {\n  /*\n   * @description     Animate typing text in an element\n   * @param   {HTML Element} elementTyping - The element which the text be typed in it\n   * @param   {string} text - The text that must be typed\n   * @param   {number} speed(ms) - The speed of typing each character\n   * @param   {number} delay(ms) - The delay before starting to type\n   * @return  {Promise}\n  */\n  var typeText = function typeText(elementTyping, text, speed, delay) {\n    return new Promise(function (resolve) {\n      return (// Use setTimeout to controll the delay before starting\n        setTimeout(function () {\n          var charIndex = 0;\n          var typing = setInterval(function () {\n            elementTyping.text(text.substr(0, ++charIndex));\n\n            if (charIndex == text.length) {\n              clearInterval(typing);\n              return resolve();\n            }\n          }, speed);\n        }, delay)\n      );\n    });\n  };\n  /*\n   * @description     Animate removing text from an element\n   * @param   {HTML Element} elementTyping - The element which the text be removed from it\n   * @param   {number} speed(ms) - The speed of removing each character\n   * @param   {number} delay(ms) - The delay before starting to remove\n   * @return  {Promise}\n  */\n\n\n  var removeText = function removeText(elementTyping, speed, delay) {\n    return new Promise(function (resolve) {\n      return (// Use setTimeout to controll the delay before starting\n        setTimeout(function () {\n          var text = elementTyping.text();\n          var removing = setInterval(function () {\n            text = text.substr(0, text.length - 1);\n            elementTyping.text(text);\n\n            if (!text.length) {\n              clearInterval(removing);\n              return resolve();\n            }\n          }, speed);\n        }, delay)\n      );\n    });\n  };\n  /*\n   * @description     Show the cursor at the end of the text\n   * @param   {HTML Element} elementTyping - The element to add an index to it\n   * @param   {number} index - The index of each .animated-typing element\n   * @param   {number} speed(ms) - The speed of blinking cursor\n  */\n\n\n  var showCursor = function showCursor(elementTyping, index, speed) {\n    // Seperate each element by adding an index attribute to them to reach individual speed for each of them\n    elementTyping.attr('data-animate-index', index); // The cursor be shown just by adding a CSS pseudo-element(::after) and animate that\n\n    $('head').append(\"\\n           <style>\\n               .animate-typing[data-animate-index=\\\"\".concat(index, \"\\\"]::after {\\n                   content: '|';\\n                   animation: animateCursor \").concat(speed, \"ms infinite alternate cubic-bezier(.68,-0.55,.27,1.55);\\n               }\\n           </style>\\n       \"));\n  };\n  /*\n   * @description     Show the cursor at the end of the text\n   * @param   {number} speed(ms) - The speed of blinking cursor\n  */\n\n\n  $('.animate-typing').each(function (index) {\n    var elementTyping = $(this); // The speed of typing each character\n\n    var typeSpeed = +elementTyping.data('type-speed') || 200; // The delay before start to type\n\n    var typeDelay = +elementTyping.data('type-delay') || 200; // The speed of removing each character\n\n    var removeSpeed = +elementTyping.data('remove-speed') || 50; // The delay before start to remove\n\n    var removeDelay = +elementTyping.data('remove-delay') || 500; // The speed of animate cursor\n\n    var cursorSpeed = +elementTyping.data('cursor-speed') || 300; // If the loop equals to true, iterate through animation sub-texts will be infinity\n\n    var loop = elementTyping.data('animate-loop') || false; // Convert the initialized text to sub-texts\n\n    var textList = elementTyping.text().split('|'); // Make the element clear from text\n\n    elementTyping.text(''); // Show the animated cursor at the end of text\n\n    showCursor(elementTyping, index, cursorSpeed); // Iterate to sub-texts for animating\n    // Use async/await because each iteration must wait for each animation to be done\n\n    _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var cycle, _iterator, _step, subText;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              cycle = 0; // Use do/while because the iteration for all sub-texts must be run at least once\n\n            case 1:\n              // Iterate for each sub-text\n              _iterator = _createForOfIteratorHelper(textList);\n              _context.prev = 2;\n\n              _iterator.s();\n\n            case 4:\n              if ((_step = _iterator.n()).done) {\n                _context.next = 14;\n                break;\n              }\n\n              subText = _step.value;\n\n              if (!cycle++) {\n                _context.next = 9;\n                break;\n              }\n\n              _context.next = 9;\n              return removeText(elementTyping, removeSpeed, removeDelay);\n\n            case 9:\n              if (!subText.trim()) {\n                _context.next = 12;\n                break;\n              }\n\n              _context.next = 12;\n              return typeText(elementTyping, subText.trim(), typeSpeed, typeDelay);\n\n            case 12:\n              _context.next = 4;\n              break;\n\n            case 14:\n              _context.next = 19;\n              break;\n\n            case 16:\n              _context.prev = 16;\n              _context.t0 = _context[\"catch\"](2);\n\n              _iterator.e(_context.t0);\n\n            case 19:\n              _context.prev = 19;\n\n              _iterator.f();\n\n              return _context.finish(19);\n\n            case 22:\n              if (loop) {\n                _context.next = 1;\n                break;\n              }\n\n            case 23:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, null, [[2, 16, 19, 22]]);\n    }))();\n  });\n  /*\n   * @description     Add keyframes animation for animating the cursor once to Head tag\n  */\n\n  (function () {\n    return $('head').append(\"\\n            <style>\\n                @keyframes animateCursor {\\n                    0% { opacity: 0; }\\n                    100% { opacity: 1; }\\n                }\\n            </style>\\n        \");\n  })();\n})(jQuery);","map":{"version":3,"sources":["/Users/shamssherif/Desktop/Work/ShamsHegab/app/javascript/packs/jquery.animateTyping.js"],"names":["$","typeText","elementTyping","text","speed","delay","Promise","resolve","setTimeout","charIndex","typing","setInterval","substr","length","clearInterval","removeText","removing","showCursor","index","attr","append","each","typeSpeed","data","typeDelay","removeSpeed","removeDelay","cursorSpeed","loop","textList","split","cycle","subText","trim","jQuery"],"mappings":"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","sourcesContent":["; ($ => {\n    /*\n     * @description     Animate typing text in an element\n     * @param   {HTML Element} elementTyping - The element which the text be typed in it\n     * @param   {string} text - The text that must be typed\n     * @param   {number} speed(ms) - The speed of typing each character\n     * @param   {number} delay(ms) - The delay before starting to type\n     * @return  {Promise}\n    */\n    const typeText = (elementTyping, text, speed, delay) =>\n        new Promise(resolve =>\n            // Use setTimeout to controll the delay before starting\n            setTimeout(() => {\n                var charIndex = 0;\n                var typing = setInterval(() => {\n                    elementTyping.text(text.substr(0, ++charIndex));\n                    if (charIndex == text.length) {\n                        clearInterval(typing);\n                        return resolve();\n                    }\n                }, speed);\n            }, delay));\n\n    /*\n     * @description     Animate removing text from an element\n     * @param   {HTML Element} elementTyping - The element which the text be removed from it\n     * @param   {number} speed(ms) - The speed of removing each character\n     * @param   {number} delay(ms) - The delay before starting to remove\n     * @return  {Promise}\n    */\n    const removeText = (elementTyping, speed, delay) =>\n        new Promise(resolve =>\n            // Use setTimeout to controll the delay before starting\n            setTimeout(function () {\n                var text = elementTyping.text();\n                var removing = setInterval(function () {\n                    text = text.substr(0, text.length - 1);\n                    elementTyping.text(text);\n                    if (!text.length) {\n                        clearInterval(removing);\n                        return resolve();\n                    }\n                }, speed);\n            }, delay));\n\n    /*\n     * @description     Show the cursor at the end of the text\n     * @param   {HTML Element} elementTyping - The element to add an index to it\n     * @param   {number} index - The index of each .animated-typing element\n     * @param   {number} speed(ms) - The speed of blinking cursor\n    */\n    const showCursor = (elementTyping, index, speed) => {\n        // Seperate each element by adding an index attribute to them to reach individual speed for each of them\n        elementTyping.attr('data-animate-index', index);\n        // The cursor be shown just by adding a CSS pseudo-element(::after) and animate that\n        $('head').append(`\n           <style>\n               .animate-typing[data-animate-index=\"${index}\"]::after {\n                   content: '|';\n                   animation: animateCursor ${speed}ms infinite alternate cubic-bezier(.68,-0.55,.27,1.55);\n               }\n           </style>\n       `);\n    }\n\n    /*\n     * @description     Show the cursor at the end of the text\n     * @param   {number} speed(ms) - The speed of blinking cursor\n    */\n    $('.animate-typing').each(function (index) {\n        const elementTyping = $(this);\n        // The speed of typing each character\n        const typeSpeed = +elementTyping.data('type-speed') || 200;\n        // The delay before start to type\n        const typeDelay = +elementTyping.data('type-delay') || 200;\n        // The speed of removing each character\n        const removeSpeed = +elementTyping.data('remove-speed') || 50;\n        // The delay before start to remove\n        const removeDelay = +elementTyping.data('remove-delay') || 500;\n        // The speed of animate cursor\n        const cursorSpeed = +elementTyping.data('cursor-speed') || 300;\n        // If the loop equals to true, iterate through animation sub-texts will be infinity\n        const loop = elementTyping.data('animate-loop') || false;\n        // Convert the initialized text to sub-texts\n        const textList = elementTyping.text().split('|');\n        // Make the element clear from text\n        elementTyping.text('');\n\n        // Show the animated cursor at the end of text\n        showCursor(elementTyping, index, cursorSpeed);\n\n        // Iterate to sub-texts for animating\n        // Use async/await because each iteration must wait for each animation to be done\n        (async () => {\n            var cycle = 0;\n            // Use do/while because the iteration for all sub-texts must be run at least once\n            do {\n                // Iterate for each sub-text\n                for (let subText of textList) {\n                    if (cycle++)\n                        await removeText(elementTyping, removeSpeed, removeDelay);\n                    if(subText.trim())\n                        await typeText(elementTyping, subText.trim(), typeSpeed, typeDelay)\n                }\n                // Set loop to true to iterate animate typing for sub-texts Infinity\n            } while (loop);\n        })();\n    });\n\n    /*\n     * @description     Add keyframes animation for animating the cursor once to Head tag\n    */\n    (() =>\n        $('head').append(`\n            <style>\n                @keyframes animateCursor {\n                    0% { opacity: 0; }\n                    100% { opacity: 1; }\n                }\n            </style>\n        `)\n    )();\n\n})(jQuery);"]},"metadata":{},"sourceType":"module"}